"use strict";import U from"../../Utilities.js";const{addEvent,removeEvent,isObject,isNumber,pick,wrap}=U;function onTickInit(){var e=this;e.treeGrid||(e.treeGrid=new TreeGridTickAdditions(e))}function onTickHover(e){e.addClass("highcharts-treegrid-node-active"),e.renderer.styledMode||e.css({textDecoration:"underline"})}function onTickHoverExit(e,t){t=isObject(t.style)?t.style:{};e.removeClass("highcharts-treegrid-node-active"),e.renderer.styledMode||e.css({textDecoration:t.textDecoration||"none"})}function renderLabelIcon(e,t){const o=e.treeGrid,i=!o.labelIcon,r=t.renderer,s=t.xy,n=t.options,d=n.width||0,a=n.height||0,l=n.padding??e.axis.linkedParent?0:5,c={x:s.x-d/2-l,y:s.y-a/2},p=t.collapsed?90:180,h=t.show&&isNumber(c.y);let b=o.labelIcon;b||(o.labelIcon=b=r.path(r.symbols[n.type](n.x||0,n.y||0,d,a)).addClass("highcharts-label-icon").add(t.group)),b[h?"show":"hide"](),r.styledMode||b.attr({cursor:"pointer",fill:pick(t.color,"#666666"),"stroke-width":1,stroke:n.lineColor,strokeWidth:n.lineWidth||0}),b[i?"attr":"animate"]({translateX:c.x,translateY:c.y,rotation:p})}function wrapGetLabelPosition(e,t,o,i,r,s,n,d,a){const l=this,c=pick(l.options&&l.options.labels,s),p=l.pos,h=l.axis,b=h.options,k="treegrid"===b.type,x=e.apply(l,[t,o,i,r,c,n,d,a]);return k&&({width:s=0,padding:e=h.linkedParent?0:5}=c&&isObject(c.symbol,!0)?c.symbol:{},t=c&&isNumber(c.indentation)?c.indentation:0,r=(i=(o=h.treeGrid.mapOfPosToGridNode)&&o[p])&&i.depth||1,x.x+=s+2*e+(r-1)*t),x}function wrapRenderLabel(e){const t=this,{pos:o,axis:i,label:r,treeGrid:s,options:n}=t,d=s?.labelIcon,a=r?.element,{treeGrid:l,options:c,chart:p,tickPositions:h}=i,b=l.mapOfPosToGridNode,k=pick(n?.labels,c?.labels),x=k&&isObject(k.symbol,!0)?k.symbol:{},y=b&&b[o],{descendants:G,depth:m}=y||{},u=y&&G&&0<G,g=m,v="treegrid"===c.type&&a,f=-1<h.indexOf(o),T="highcharts-treegrid-node-",w=T+"level-",C=p.styledMode;var E;v&&y&&r.removeClass(new RegExp(w+".*")).addClass(w+g),e.apply(t,Array.prototype.slice.call(arguments,1)),v&&u?(e=l.isCollapsed(y),renderLabelIcon(t,{color:!C&&r.styles.color||"",collapsed:e,group:r.parentGroup,options:x,renderer:r.renderer,show:f,xy:r.xy}),E=T+(e?"expanded":"collapsed"),r.addClass(T+(e?"collapsed":"expanded")).removeClass(E),C||r.css({cursor:"pointer"}),[r,d].forEach(e=>{e&&!e.attachedTreeGridEvents&&(addEvent(e.element,"mouseover",function(){onTickHover(r)}),addEvent(e.element,"mouseout",function(){onTickHoverExit(r,k)}),addEvent(e.element,"click",function(){s.toggleCollapse()}),e.attachedTreeGridEvents=!0)})):d&&(removeEvent(a),r?.css({cursor:"default"}),d.destroy())}class TreeGridTickAdditions{static compose(e){const t=e.prototype;t.toggleCollapse||(addEvent(e,"init",onTickInit),wrap(t,"getLabelPosition",wrapGetLabelPosition),wrap(t,"renderLabel",wrapRenderLabel),t.collapse=function(e){this.treeGrid.collapse(e)},t.expand=function(e){this.treeGrid.expand(e)},t.toggleCollapse=function(e){this.treeGrid.toggleCollapse(e)})}constructor(e){this.tick=e}collapse(e){const t=this.tick,o=t.axis,i=o.brokenAxis;var r;i&&o.treeGrid.mapOfPosToGridNode&&(r=t.pos,r=o.treeGrid.mapOfPosToGridNode[r],r=o.treeGrid.collapse(r),i.setBreaks(r,pick(e,!0)))}destroy(){this.labelIcon&&this.labelIcon.destroy()}expand(e){const{pos:t,axis:o}=this.tick,{treeGrid:i,brokenAxis:r}=o,s=i.mapOfPosToGridNode;var n;r&&s&&(n=s[t],n=i.expand(n),r.setBreaks(n,pick(e,!0)))}toggleCollapse(e){const t=this.tick,o=t.axis,i=o.brokenAxis;var r;i&&o.treeGrid.mapOfPosToGridNode&&(r=t.pos,r=o.treeGrid.mapOfPosToGridNode[r],r=o.treeGrid.toggleCollapse(r),i.setBreaks(r,pick(e,!0)))}}export default TreeGridTickAdditions;